# Generated by Django 4.1.9 on 2023-06-07 15:41

from django.db import migrations

SQL = """
----------------------------------------------------------------------
-- Handles deletion of flow runs
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_delete() RETURNS TRIGGER AS $$
DECLARE
    p INT;
    _path_json JSONB;
    _path_len INT;
BEGIN
    -- if this is a user delete then remove from results
    IF OLD.delete_from_results THEN
        PERFORM temba_update_category_counts(OLD.flow_id, NULL, OLD.results::json);

        -- nothing more to do if path was empty
        IF OLD.path IS NULL OR OLD.path = '[]' THEN RETURN NULL; END IF;

        -- parse path as JSON
        _path_json := OLD.path::json;
        _path_len := jsonb_array_length(_path_json);

        -- for each step in the path, decrement the path count
        p := 1;
        LOOP
            EXIT WHEN p >= _path_len;

            -- it's possible that steps from old flows don't have exit_uuid
            IF (_path_json->(p-1)->'exit_uuid') IS NOT NULL THEN
                PERFORM temba_insert_flowpathcount(
                    OLD.flow_id,
                    UUID(_path_json->(p-1)->>'exit_uuid'),
                    UUID(_path_json->p->>'node_uuid'),
                    timestamptz(_path_json->p->>'arrived_on'),
                    -1
                );
            END IF;

            p := p + 1;
        END LOOP;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------------
-- Handles insertion of flow runs
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_insert() RETURNS TRIGGER AS $$
DECLARE
    p INT;
    _path_json JSONB;
    _path_len INT;
BEGIN
    -- nothing to do if path is empty
    IF NEW.path IS NULL OR NEW.path = '[]' THEN RETURN NULL; END IF;

    -- parse path as JSON
    _path_json := NEW.path::json;
    _path_len := jsonb_array_length(_path_json);

    -- for each step in the path, increment the path count, and record a recent run
    p := 1;
    LOOP
        EXIT WHEN p >= _path_len;

        PERFORM temba_insert_flowpathcount(
            NEW.flow_id,
            UUID(_path_json->(p-1)->>'exit_uuid'),
            UUID(_path_json->p->>'node_uuid'),
            timestamptz(_path_json->p->>'arrived_on'),
            1
        );
        p := p + 1;
    END LOOP;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------------
-- Handles changes relating to a flow run's path
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_path_change() RETURNS TRIGGER AS $$
DECLARE
  p INT;
  _old_path_json JSONB;
  _new_path_json JSONB;
  _old_path_len INT;
  _new_path_len INT;
  _old_last_step_uuid TEXT;
BEGIN
    _old_path_json := COALESCE(OLD.path, '[]')::jsonb;
    _new_path_json := COALESCE(NEW.path, '[]')::jsonb;
    _old_path_len := jsonb_array_length(_old_path_json);
    _new_path_len := jsonb_array_length(_new_path_json);

    -- we don't support rewinding run paths, so the new path must be longer than the old
    IF _new_path_len < _old_path_len THEN RAISE EXCEPTION 'Cannot rewind a flow run path'; END IF;

    -- if we have an old path, find its last step in the new path, and that will be our starting point
    IF _old_path_len > 1 THEN
        _old_last_step_uuid := _old_path_json->(_old_path_len-1)->>'uuid';

        -- old and new paths end with same step so path activity doesn't change
        IF _old_last_step_uuid = _new_path_json->(_new_path_len-1)->>'uuid' THEN
            RETURN NULL;
        END IF;

        p := _new_path_len - 1;
        LOOP
            EXIT WHEN p = 1 OR _new_path_json->(p-1)->>'uuid' = _old_last_step_uuid;
            p := p - 1;
        END LOOP;
    ELSE
        p := 1;
    END IF;

    LOOP
      EXIT WHEN p >= _new_path_len;
      PERFORM temba_insert_flowpathcount(
          NEW.flow_id,
          UUID(_new_path_json->(p-1)->>'exit_uuid'),
          UUID(_new_path_json->p->>'node_uuid'),
          timestamptz(_new_path_json->p->>'arrived_on'),
          1
      );
      p := p + 1;
    END LOOP;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------------
-- Handles DELETE statements on flowrun table
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_on_delete() RETURNS TRIGGER AS $$
BEGIN
    -- add negative status counts for all rows being deleted manually
    INSERT INTO flows_flowrunstatuscount("flow_id", "status", "count", "is_squashed")
    SELECT flow_id, status, -count(*), FALSE FROM oldtab
    WHERE delete_from_results = TRUE GROUP BY flow_id, status;

    -- add negative node counts for any runs sitting at a node
    INSERT INTO flows_flownodecount("flow_id", "node_uuid", "count", "is_squashed")
    SELECT flow_id, current_node_uuid, -count(*), FALSE FROM oldtab
    WHERE status IN ('A', 'W') AND current_node_uuid IS NOT NULL GROUP BY flow_id, current_node_uuid;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------------
-- Handles INSERT statements on flowrun table
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_on_insert() RETURNS TRIGGER AS $$
BEGIN
    -- add status counts for all new status values
    INSERT INTO flows_flowrunstatuscount("flow_id", "status", "count", "is_squashed")
    SELECT flow_id, status, count(*), FALSE FROM newtab GROUP BY flow_id, status;

    -- add start counts for all new start values
    INSERT INTO flows_flowstartcount("start_id", "count", "is_squashed")
    SELECT start_id, count(*), FALSE FROM newtab WHERE start_id IS NOT NULL GROUP BY start_id;

    -- add node counts for all new current node values
    INSERT INTO flows_flownodecount("flow_id", "node_uuid", "count", "is_squashed")
    SELECT flow_id, current_node_uuid, count(*), FALSE FROM newtab
    WHERE status IN ('A', 'W') AND current_node_uuid IS NOT NULL GROUP BY flow_id, current_node_uuid;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------------
-- Handles UPDATE statements on flowrun table
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_on_update() RETURNS TRIGGER AS $$
BEGIN
    -- add negative status counts for all old status values that don't match the new ones
    INSERT INTO flows_flowrunstatuscount("flow_id", "status", "count", "is_squashed")
    SELECT o.flow_id, o.status, -count(*), FALSE FROM oldtab o
    INNER JOIN newtab n ON n.id = o.id
    WHERE o.status != n.status
    GROUP BY o.flow_id, o.status;

    -- add status counts for all new status values that don't match the old ones
    INSERT INTO flows_flowrunstatuscount("flow_id", "status", "count", "is_squashed")
    SELECT n.flow_id, n.status, count(*), FALSE FROM newtab n
    INNER JOIN oldtab o ON o.id = n.id
    WHERE o.status != n.status
    GROUP BY n.flow_id, n.status;

    -- add negative node counts for all old current node values that don't match the new ones
    INSERT INTO flows_flownodecount("flow_id", "node_uuid", "count", "is_squashed")
    SELECT o.flow_id, o.current_node_uuid, -count(*), FALSE FROM oldtab o
    INNER JOIN newtab n ON n.id = o.id
    WHERE o.current_node_uuid IS NOT NULL AND o.status IN ('A', 'W') AND (o.current_node_uuid != n.current_node_uuid OR n.status NOT IN ('A', 'W'))
    GROUP BY o.flow_id, o.current_node_uuid;

    -- add node counts for all new current node values that don't match the old ones
    INSERT INTO flows_flownodecount("flow_id", "node_uuid", "count", "is_squashed")
    SELECT n.flow_id, n.current_node_uuid, count(*), FALSE FROM newtab n
    INNER JOIN oldtab o ON o.id = n.id
    WHERE n.current_node_uuid IS NOT NULL AND o.current_node_uuid != n.current_node_uuid AND n.status IN ('A', 'W')
    GROUP BY n.flow_id, n.current_node_uuid;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP FUNCTION temba_insert_flownodecount(INTEGER, UUID, INTEGER);
"""


class Migration(migrations.Migration):
    dependencies = [("flows", "0319_remove_flowstart_extra_and_more")]

    operations = [migrations.RunSQL(SQL)]
